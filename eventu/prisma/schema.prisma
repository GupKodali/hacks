// prisma/schema.prisma
// Full schema for: Auth0 users + onboarding (hobbies, availability) + weekly matching + events/invites + attendance + notifications + match runs.
// Works with SQL. Default: PostgreSQL. If you're using MySQL, switch provider to "mysql" and remove/adjust @db.* types as needed.

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
}

//
// ENUMS
//

enum UserStatus {
  ACTIVE
  PAUSED
  BANNED
}

enum AvailabilityWeekStatus {
  DRAFT
  SUBMITTED
  LOCKED
}

enum VenueType {
  PARK
  COURT
  LIBRARY
  CAFE
  COMMUNITY_CENTER
  GYM
  OTHER
}

enum VenueMode {
  PUBLIC_OUTDOOR
  PUBLIC_INDOOR
}

enum EventStatus {
  DRAFT
  PENDING_ACCEPTANCE
  CONFIRMED
  CANCELLED
  COMPLETED
}

enum InviteStatus {
  PENDING
  ACCEPTED
  DECLINED
  EXPIRED
  REMOVED
}

enum InviteSource {
  PRIMARY_MATCH
  QUICK_PLAY_BACKFILL
}

enum AttendanceStatus {
  ATTENDED
  NO_SHOW
  LATE_CANCEL
  UNKNOWN
}

enum AttendanceConfirmedBy {
  SELF
  GROUP
  SYSTEM
}

enum NotificationChannel {
  PUSH
  EMAIL
  SMS
}

enum NotificationType {
  ASSIGNMENT_RELEASED
  ACCEPTANCE_REMINDER
  QUICK_PLAY_INVITE
  EVENT_CONFIRMED
  EVENT_CANCELLED
  EVENT_UPDATED
  POST_EVENT_CHECKIN
}

enum MatchRunStatus {
  RUNNING
  SUCCESS
  FAILED
}

//
// CORE MODELS
//

model User {
  id                 String     @id @default(cuid())
  auth0Sub           String     @unique @db.VarChar(255)
  email              String?    @db.VarChar(255)
  name               String?    @db.VarChar(255)
  status             UserStatus @default(ACTIVE)

  // Onboarding
  onboardingComplete Boolean    @default(false)

  // Preferences / matching knobs
  quickPlayEnabled     Boolean  @default(false)
  maxTravelDistanceKm  Int      @default(10)

  // Reliability (can be computed; storing cached values is handy for matching)
  reliabilityScore     Int      @default(100) // 0-100
  noShowCountRolling30 Int      @default(0)

  // Location scoping
  cityId             String?
  city               City?      @relation(fields: [cityId], references: [id], onDelete: SetNull)

  createdAt          DateTime   @default(now())
  updatedAt          DateTime   @updatedAt

  // Relations
  hobbies            UserHobby[]
  availabilityWeeks  AvailabilityWeek[]
  invites            EventInvite[]
  attendance         AttendanceRecord[]
  notifications      NotificationLog[]

  @@index([email])
  @@index([cityId])
}

model City {
  id        String   @id @default(cuid())
  name      String   @db.VarChar(120)
  state     String?  @db.VarChar(60)
  country   String?  @db.VarChar(60)

  // Optional map center for bounding / defaults
  lat       Decimal? @db.Decimal(9, 6)
  lng       Decimal? @db.Decimal(9, 6)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  users     User[]
  venues    Venue[]

  @@unique([name, state, country])
}

model Hobby {
  id        String  @id @default(cuid())
  name      String  @unique @db.VarChar(120)
  category  String? @db.VarChar(60)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  users     UserHobby[]
  eventTypeLinks EventTypeHobby[]
}

model UserHobby {
  id        String @id @default(cuid())
  userId    String
  hobbyId   String

  // optional: ranking later (1..3). enforce max 3 hobbies per user in app logic.
  preferenceWeight Int? @default(1)

  createdAt DateTime @default(now())

  user   User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  hobby  Hobby @relation(fields: [hobbyId], references: [id], onDelete: Cascade)

  @@unique([userId, hobbyId])
  @@index([hobbyId])
}

//
// AVAILABILITY
//

model AvailabilityWeek {
  id            String                @id @default(cuid())
  userId        String
  weekStartDate DateTime              // normalized start of week (e.g., Monday 00:00 in user tz or app tz)
  status        AvailabilityWeekStatus @default(DRAFT)
  submittedAt   DateTime?
  timezone      String?               @db.VarChar(64)

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  user   User @relation(fields: [userId], references: [id], onDelete: Cascade)
  blocks AvailabilityBlock[]

  @@unique([userId, weekStartDate])
  @@index([weekStartDate])
}

model AvailabilityBlock {
  id                 String   @id @default(cuid())
  availabilityWeekId String
  startAt            DateTime
  endAt              DateTime
  label              String?  @db.VarChar(80)

  createdAt          DateTime @default(now())
  updatedAt          DateTime @updatedAt

  week AvailabilityWeek @relation(fields: [availabilityWeekId], references: [id], onDelete: Cascade)

  @@index([availabilityWeekId])
  @@index([startAt, endAt])
}

//
// EVENT TYPES + VENUES
//

model EventType {
  id                String    @id @default(cuid())
  name              String    @unique @db.VarChar(120)

  minSize           Int
  targetSize        Int
  maxSize           Int
  slotLengthMinutes Int
  venueMode         VenueMode @default(PUBLIC_OUTDOOR)

  description       String?   @db.VarChar(300)
  equipmentNotes    String?   @db.VarChar(300)

  createdAt         DateTime  @default(now())
  updatedAt         DateTime  @updatedAt

  events            Event[]
  hobbyLinks        EventTypeHobby[]
}

model EventTypeHobby {
  id         String   @id @default(cuid())
  eventTypeId String
  hobbyId    String

  createdAt  DateTime @default(now())

  eventType EventType @relation(fields: [eventTypeId], references: [id], onDelete: Cascade)
  hobby     Hobby     @relation(fields: [hobbyId], references: [id], onDelete: Cascade)

  @@unique([eventTypeId, hobbyId])
  @@index([hobbyId])
}

model Venue {
  id        String    @id @default(cuid())
  cityId    String
  name      String    @db.VarChar(160)
  address   String?   @db.VarChar(240)

  lat       Decimal?  @db.Decimal(9, 6)
  lng       Decimal?  @db.Decimal(9, 6)

  venueType VenueType @default(OTHER)
  isActive  Boolean   @default(true)
  notes     String?   @db.VarChar(400)

  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  city      City   @relation(fields: [cityId], references: [id], onDelete: Cascade)
  events    Event[]

  @@index([cityId])
  @@index([isActive])
}

//
// EVENTS + INVITES + ATTENDANCE
//

model Event {
  id            String      @id @default(cuid())

  // ties this event to a specific matching week
  weekStartDate DateTime

  eventTypeId   String
  venueId       String

  startsAt      DateTime
  endsAt        DateTime

  status        EventStatus @default(PENDING_ACCEPTANCE)

  // snapshot constraints from EventType at creation time
  minSize       Int
  targetSize    Int
  maxSize       Int

  createdBySystem Boolean   @default(true)
  finalizedAt     DateTime?
  cancelReason    String?   @db.VarChar(240)

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  eventType   EventType @relation(fields: [eventTypeId], references: [id], onDelete: Restrict)
  venue       Venue     @relation(fields: [venueId], references: [id], onDelete: Restrict)

  invites     EventInvite[]
  attendance  AttendanceRecord[]

  @@index([weekStartDate])
  @@index([startsAt])
  @@index([eventTypeId])
  @@index([venueId])
}

model EventInvite {
  id         String       @id @default(cuid())
  eventId    String
  userId     String

  status     InviteStatus @default(PENDING)
  source     InviteSource @default(PRIMARY_MATCH)

  invitedAt  DateTime     @default(now())
  respondedAt DateTime?
  deadlineAt DateTime     // Monday noon cutoff

  createdAt  DateTime     @default(now())
  updatedAt  DateTime     @updatedAt

  event      Event @relation(fields: [eventId], references: [id], onDelete: Cascade)
  user       User  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([eventId, userId])
  @@index([userId])
  @@index([status])
  @@index([deadlineAt])
}

model AttendanceRecord {
  id          String               @id @default(cuid())
  eventId     String
  userId      String

  status      AttendanceStatus     @default(UNKNOWN)
  confirmedBy AttendanceConfirmedBy? // optional; depends on MVP flow
  recordedAt  DateTime             @default(now())

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  event       Event @relation(fields: [eventId], references: [id], onDelete: Cascade)
  user        User  @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([eventId, userId])
  @@index([userId])
  @@index([status])
}

//
// OPS / OBSERVABILITY (OPTIONAL BUT VERY USEFUL)
//

model NotificationLog {
  id        String              @id @default(cuid())
  userId    String

  type      NotificationType
  channel   NotificationChannel
  sentAt    DateTime            @default(now())

  // store small metadata (ids, deep links). keep under control.
  metadata  Json?

  user      User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([type])
  @@index([sentAt])
}

model MatchRun {
  id            String        @id @default(cuid())
  weekStartDate DateTime
  status        MatchRunStatus @default(RUNNING)

  startedAt     DateTime      @default(now())
  finishedAt    DateTime?

  // operational stats (eventsCreated, usersMatched, backfillsSent, etc.)
  stats         Json?

  errorMessage  String?       @db.VarChar(500)

  @@unique([weekStartDate])
  @@index([status])
}